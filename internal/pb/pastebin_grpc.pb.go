// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: internal/pb/pastebin.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PasteService_CreatePaste_FullMethodName = "/pastebin.PasteService/CreatePaste"
	PasteService_GetPaste_FullMethodName    = "/pastebin.PasteService/GetPaste"
	PasteService_ListPastes_FullMethodName  = "/pastebin.PasteService/ListPastes"
	PasteService_UpdatePaste_FullMethodName = "/pastebin.PasteService/UpdatePaste"
	PasteService_DeletePaste_FullMethodName = "/pastebin.PasteService/DeletePaste"
)

// PasteServiceClient is the client API for PasteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PasteServiceClient interface {
	CreatePaste(ctx context.Context, in *Paste, opts ...grpc.CallOption) (*Paste, error)
	GetPaste(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*Paste, error)
	ListPastes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Paste], error)
	UpdatePaste(ctx context.Context, in *Paste, opts ...grpc.CallOption) (*Paste, error)
	DeletePaste(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*Status, error)
}

type pasteServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPasteServiceClient(cc grpc.ClientConnInterface) PasteServiceClient {
	return &pasteServiceClient{cc}
}

func (c *pasteServiceClient) CreatePaste(ctx context.Context, in *Paste, opts ...grpc.CallOption) (*Paste, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Paste)
	err := c.cc.Invoke(ctx, PasteService_CreatePaste_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pasteServiceClient) GetPaste(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*Paste, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Paste)
	err := c.cc.Invoke(ctx, PasteService_GetPaste_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pasteServiceClient) ListPastes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Paste], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PasteService_ServiceDesc.Streams[0], PasteService_ListPastes_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, Paste]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PasteService_ListPastesClient = grpc.ServerStreamingClient[Paste]

func (c *pasteServiceClient) UpdatePaste(ctx context.Context, in *Paste, opts ...grpc.CallOption) (*Paste, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Paste)
	err := c.cc.Invoke(ctx, PasteService_UpdatePaste_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pasteServiceClient) DeletePaste(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, PasteService_DeletePaste_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PasteServiceServer is the server API for PasteService service.
// All implementations must embed UnimplementedPasteServiceServer
// for forward compatibility.
type PasteServiceServer interface {
	CreatePaste(context.Context, *Paste) (*Paste, error)
	GetPaste(context.Context, *IDRequest) (*Paste, error)
	ListPastes(*Empty, grpc.ServerStreamingServer[Paste]) error
	UpdatePaste(context.Context, *Paste) (*Paste, error)
	DeletePaste(context.Context, *IDRequest) (*Status, error)
	mustEmbedUnimplementedPasteServiceServer()
}

// UnimplementedPasteServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPasteServiceServer struct{}

func (UnimplementedPasteServiceServer) CreatePaste(context.Context, *Paste) (*Paste, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePaste not implemented")
}
func (UnimplementedPasteServiceServer) GetPaste(context.Context, *IDRequest) (*Paste, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaste not implemented")
}
func (UnimplementedPasteServiceServer) ListPastes(*Empty, grpc.ServerStreamingServer[Paste]) error {
	return status.Errorf(codes.Unimplemented, "method ListPastes not implemented")
}
func (UnimplementedPasteServiceServer) UpdatePaste(context.Context, *Paste) (*Paste, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePaste not implemented")
}
func (UnimplementedPasteServiceServer) DeletePaste(context.Context, *IDRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePaste not implemented")
}
func (UnimplementedPasteServiceServer) mustEmbedUnimplementedPasteServiceServer() {}
func (UnimplementedPasteServiceServer) testEmbeddedByValue()                      {}

// UnsafePasteServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PasteServiceServer will
// result in compilation errors.
type UnsafePasteServiceServer interface {
	mustEmbedUnimplementedPasteServiceServer()
}

func RegisterPasteServiceServer(s grpc.ServiceRegistrar, srv PasteServiceServer) {
	// If the following call pancis, it indicates UnimplementedPasteServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PasteService_ServiceDesc, srv)
}

func _PasteService_CreatePaste_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Paste)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasteServiceServer).CreatePaste(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasteService_CreatePaste_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasteServiceServer).CreatePaste(ctx, req.(*Paste))
	}
	return interceptor(ctx, in, info, handler)
}

func _PasteService_GetPaste_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasteServiceServer).GetPaste(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasteService_GetPaste_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasteServiceServer).GetPaste(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PasteService_ListPastes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PasteServiceServer).ListPastes(m, &grpc.GenericServerStream[Empty, Paste]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PasteService_ListPastesServer = grpc.ServerStreamingServer[Paste]

func _PasteService_UpdatePaste_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Paste)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasteServiceServer).UpdatePaste(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasteService_UpdatePaste_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasteServiceServer).UpdatePaste(ctx, req.(*Paste))
	}
	return interceptor(ctx, in, info, handler)
}

func _PasteService_DeletePaste_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasteServiceServer).DeletePaste(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasteService_DeletePaste_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasteServiceServer).DeletePaste(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PasteService_ServiceDesc is the grpc.ServiceDesc for PasteService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PasteService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pastebin.PasteService",
	HandlerType: (*PasteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePaste",
			Handler:    _PasteService_CreatePaste_Handler,
		},
		{
			MethodName: "GetPaste",
			Handler:    _PasteService_GetPaste_Handler,
		},
		{
			MethodName: "UpdatePaste",
			Handler:    _PasteService_UpdatePaste_Handler,
		},
		{
			MethodName: "DeletePaste",
			Handler:    _PasteService_DeletePaste_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListPastes",
			Handler:       _PasteService_ListPastes_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "internal/pb/pastebin.proto",
}

const (
	UserService_CreateUser_FullMethodName = "/pastebin.UserService/CreateUser"
	UserService_GetUser_FullMethodName    = "/pastebin.UserService/GetUser"
	UserService_ListUsers_FullMethodName  = "/pastebin.UserService/ListUsers"
	UserService_UpdateUser_FullMethodName = "/pastebin.UserService/UpdateUser"
	UserService_DeleteUser_FullMethodName = "/pastebin.UserService/DeleteUser"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	GetUser(ctx context.Context, in *IDRequestInt, opts ...grpc.CallOption) (*User, error)
	ListUsers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error)
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	DeleteUser(ctx context.Context, in *IDRequestInt, opts ...grpc.CallOption) (*Status, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUser(ctx context.Context, in *IDRequestInt, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ListUsers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[User], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &UserService_ServiceDesc.Streams[0], UserService_ListUsers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, User]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UserService_ListUsersClient = grpc.ServerStreamingClient[User]

func (c *userServiceClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *IDRequestInt, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	CreateUser(context.Context, *User) (*User, error)
	GetUser(context.Context, *IDRequestInt) (*User, error)
	ListUsers(*Empty, grpc.ServerStreamingServer[User]) error
	UpdateUser(context.Context, *User) (*User, error)
	DeleteUser(context.Context, *IDRequestInt) (*Status, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) GetUser(context.Context, *IDRequestInt) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) ListUsers(*Empty, grpc.ServerStreamingServer[User]) error {
	return status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *IDRequestInt) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequestInt)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*IDRequestInt))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ListUsers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserServiceServer).ListUsers(m, &grpc.GenericServerStream[Empty, User]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UserService_ListUsersServer = grpc.ServerStreamingServer[User]

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequestInt)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*IDRequestInt))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pastebin.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListUsers",
			Handler:       _UserService_ListUsers_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "internal/pb/pastebin.proto",
}

const (
	StatsService_CreateStats_FullMethodName = "/pastebin.StatsService/CreateStats"
	StatsService_GetStats_FullMethodName    = "/pastebin.StatsService/GetStats"
	StatsService_ListStats_FullMethodName   = "/pastebin.StatsService/ListStats"
	StatsService_UpdateStats_FullMethodName = "/pastebin.StatsService/UpdateStats"
	StatsService_DeleteStats_FullMethodName = "/pastebin.StatsService/DeleteStats"
)

// StatsServiceClient is the client API for StatsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StatsServiceClient interface {
	CreateStats(ctx context.Context, in *Stats, opts ...grpc.CallOption) (*Stats, error)
	GetStats(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*Stats, error)
	ListStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Stats], error)
	UpdateStats(ctx context.Context, in *Stats, opts ...grpc.CallOption) (*Status, error)
	DeleteStats(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*Status, error)
}

type statsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStatsServiceClient(cc grpc.ClientConnInterface) StatsServiceClient {
	return &statsServiceClient{cc}
}

func (c *statsServiceClient) CreateStats(ctx context.Context, in *Stats, opts ...grpc.CallOption) (*Stats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Stats)
	err := c.cc.Invoke(ctx, StatsService_CreateStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statsServiceClient) GetStats(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*Stats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Stats)
	err := c.cc.Invoke(ctx, StatsService_GetStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statsServiceClient) ListStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Stats], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StatsService_ServiceDesc.Streams[0], StatsService_ListStats_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, Stats]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StatsService_ListStatsClient = grpc.ServerStreamingClient[Stats]

func (c *statsServiceClient) UpdateStats(ctx context.Context, in *Stats, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, StatsService_UpdateStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statsServiceClient) DeleteStats(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, StatsService_DeleteStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StatsServiceServer is the server API for StatsService service.
// All implementations must embed UnimplementedStatsServiceServer
// for forward compatibility.
type StatsServiceServer interface {
	CreateStats(context.Context, *Stats) (*Stats, error)
	GetStats(context.Context, *IDRequest) (*Stats, error)
	ListStats(*Empty, grpc.ServerStreamingServer[Stats]) error
	UpdateStats(context.Context, *Stats) (*Status, error)
	DeleteStats(context.Context, *IDRequest) (*Status, error)
	mustEmbedUnimplementedStatsServiceServer()
}

// UnimplementedStatsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStatsServiceServer struct{}

func (UnimplementedStatsServiceServer) CreateStats(context.Context, *Stats) (*Stats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStats not implemented")
}
func (UnimplementedStatsServiceServer) GetStats(context.Context, *IDRequest) (*Stats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedStatsServiceServer) ListStats(*Empty, grpc.ServerStreamingServer[Stats]) error {
	return status.Errorf(codes.Unimplemented, "method ListStats not implemented")
}
func (UnimplementedStatsServiceServer) UpdateStats(context.Context, *Stats) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStats not implemented")
}
func (UnimplementedStatsServiceServer) DeleteStats(context.Context, *IDRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStats not implemented")
}
func (UnimplementedStatsServiceServer) mustEmbedUnimplementedStatsServiceServer() {}
func (UnimplementedStatsServiceServer) testEmbeddedByValue()                      {}

// UnsafeStatsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StatsServiceServer will
// result in compilation errors.
type UnsafeStatsServiceServer interface {
	mustEmbedUnimplementedStatsServiceServer()
}

func RegisterStatsServiceServer(s grpc.ServiceRegistrar, srv StatsServiceServer) {
	// If the following call pancis, it indicates UnimplementedStatsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StatsService_ServiceDesc, srv)
}

func _StatsService_CreateStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Stats)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsServiceServer).CreateStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StatsService_CreateStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsServiceServer).CreateStats(ctx, req.(*Stats))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatsService_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsServiceServer).GetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StatsService_GetStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsServiceServer).GetStats(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatsService_ListStats_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StatsServiceServer).ListStats(m, &grpc.GenericServerStream[Empty, Stats]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StatsService_ListStatsServer = grpc.ServerStreamingServer[Stats]

func _StatsService_UpdateStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Stats)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsServiceServer).UpdateStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StatsService_UpdateStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsServiceServer).UpdateStats(ctx, req.(*Stats))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatsService_DeleteStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsServiceServer).DeleteStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StatsService_DeleteStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsServiceServer).DeleteStats(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StatsService_ServiceDesc is the grpc.ServiceDesc for StatsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StatsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pastebin.StatsService",
	HandlerType: (*StatsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateStats",
			Handler:    _StatsService_CreateStats_Handler,
		},
		{
			MethodName: "GetStats",
			Handler:    _StatsService_GetStats_Handler,
		},
		{
			MethodName: "UpdateStats",
			Handler:    _StatsService_UpdateStats_Handler,
		},
		{
			MethodName: "DeleteStats",
			Handler:    _StatsService_DeleteStats_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListStats",
			Handler:       _StatsService_ListStats_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "internal/pb/pastebin.proto",
}

const (
	ShortURLService_CreateShortURL_FullMethodName = "/pastebin.ShortURLService/CreateShortURL"
	ShortURLService_GetShortURL_FullMethodName    = "/pastebin.ShortURLService/GetShortURL"
	ShortURLService_ListShortURLs_FullMethodName  = "/pastebin.ShortURLService/ListShortURLs"
	ShortURLService_UpdateShortURL_FullMethodName = "/pastebin.ShortURLService/UpdateShortURL"
	ShortURLService_DeleteShortURL_FullMethodName = "/pastebin.ShortURLService/DeleteShortURL"
)

// ShortURLServiceClient is the client API for ShortURLService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShortURLServiceClient interface {
	CreateShortURL(ctx context.Context, in *ShortURL, opts ...grpc.CallOption) (*ShortURL, error)
	GetShortURL(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*ShortURL, error)
	ListShortURLs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ShortURL], error)
	UpdateShortURL(ctx context.Context, in *ShortURL, opts ...grpc.CallOption) (*Status, error)
	DeleteShortURL(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*Status, error)
}

type shortURLServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewShortURLServiceClient(cc grpc.ClientConnInterface) ShortURLServiceClient {
	return &shortURLServiceClient{cc}
}

func (c *shortURLServiceClient) CreateShortURL(ctx context.Context, in *ShortURL, opts ...grpc.CallOption) (*ShortURL, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShortURL)
	err := c.cc.Invoke(ctx, ShortURLService_CreateShortURL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shortURLServiceClient) GetShortURL(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*ShortURL, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShortURL)
	err := c.cc.Invoke(ctx, ShortURLService_GetShortURL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shortURLServiceClient) ListShortURLs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ShortURL], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ShortURLService_ServiceDesc.Streams[0], ShortURLService_ListShortURLs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, ShortURL]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ShortURLService_ListShortURLsClient = grpc.ServerStreamingClient[ShortURL]

func (c *shortURLServiceClient) UpdateShortURL(ctx context.Context, in *ShortURL, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, ShortURLService_UpdateShortURL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shortURLServiceClient) DeleteShortURL(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, ShortURLService_DeleteShortURL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShortURLServiceServer is the server API for ShortURLService service.
// All implementations must embed UnimplementedShortURLServiceServer
// for forward compatibility.
type ShortURLServiceServer interface {
	CreateShortURL(context.Context, *ShortURL) (*ShortURL, error)
	GetShortURL(context.Context, *IDRequest) (*ShortURL, error)
	ListShortURLs(*Empty, grpc.ServerStreamingServer[ShortURL]) error
	UpdateShortURL(context.Context, *ShortURL) (*Status, error)
	DeleteShortURL(context.Context, *IDRequest) (*Status, error)
	mustEmbedUnimplementedShortURLServiceServer()
}

// UnimplementedShortURLServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedShortURLServiceServer struct{}

func (UnimplementedShortURLServiceServer) CreateShortURL(context.Context, *ShortURL) (*ShortURL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateShortURL not implemented")
}
func (UnimplementedShortURLServiceServer) GetShortURL(context.Context, *IDRequest) (*ShortURL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShortURL not implemented")
}
func (UnimplementedShortURLServiceServer) ListShortURLs(*Empty, grpc.ServerStreamingServer[ShortURL]) error {
	return status.Errorf(codes.Unimplemented, "method ListShortURLs not implemented")
}
func (UnimplementedShortURLServiceServer) UpdateShortURL(context.Context, *ShortURL) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateShortURL not implemented")
}
func (UnimplementedShortURLServiceServer) DeleteShortURL(context.Context, *IDRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteShortURL not implemented")
}
func (UnimplementedShortURLServiceServer) mustEmbedUnimplementedShortURLServiceServer() {}
func (UnimplementedShortURLServiceServer) testEmbeddedByValue()                         {}

// UnsafeShortURLServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShortURLServiceServer will
// result in compilation errors.
type UnsafeShortURLServiceServer interface {
	mustEmbedUnimplementedShortURLServiceServer()
}

func RegisterShortURLServiceServer(s grpc.ServiceRegistrar, srv ShortURLServiceServer) {
	// If the following call pancis, it indicates UnimplementedShortURLServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ShortURLService_ServiceDesc, srv)
}

func _ShortURLService_CreateShortURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShortURL)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShortURLServiceServer).CreateShortURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShortURLService_CreateShortURL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShortURLServiceServer).CreateShortURL(ctx, req.(*ShortURL))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShortURLService_GetShortURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShortURLServiceServer).GetShortURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShortURLService_GetShortURL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShortURLServiceServer).GetShortURL(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShortURLService_ListShortURLs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShortURLServiceServer).ListShortURLs(m, &grpc.GenericServerStream[Empty, ShortURL]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ShortURLService_ListShortURLsServer = grpc.ServerStreamingServer[ShortURL]

func _ShortURLService_UpdateShortURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShortURL)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShortURLServiceServer).UpdateShortURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShortURLService_UpdateShortURL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShortURLServiceServer).UpdateShortURL(ctx, req.(*ShortURL))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShortURLService_DeleteShortURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShortURLServiceServer).DeleteShortURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShortURLService_DeleteShortURL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShortURLServiceServer).DeleteShortURL(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ShortURLService_ServiceDesc is the grpc.ServiceDesc for ShortURLService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShortURLService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pastebin.ShortURLService",
	HandlerType: (*ShortURLServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateShortURL",
			Handler:    _ShortURLService_CreateShortURL_Handler,
		},
		{
			MethodName: "GetShortURL",
			Handler:    _ShortURLService_GetShortURL_Handler,
		},
		{
			MethodName: "UpdateShortURL",
			Handler:    _ShortURLService_UpdateShortURL_Handler,
		},
		{
			MethodName: "DeleteShortURL",
			Handler:    _ShortURLService_DeleteShortURL_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListShortURLs",
			Handler:       _ShortURLService_ListShortURLs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "internal/pb/pastebin.proto",
}
